### جدول اصلاح موارد نقض

سپهر نوروزی چاکلی

| اصل | کلاس تغییر یافته | مشکل در نسخه قبلی | اقدام اصلاحی / رفع نقض |
|------|------------------|--------------------|--------------------------|
| **SRP** | `ReservationService` | این کلاس چندین مسئولیت مختلف داشت (انجام رزرو، محاسبه تخفیف، پرداخت، چاپ فاکتور و ارسال پیام). این تمرکز بیش‌ازحد باعث نقض اصل مسئولیت یگانه شده بود. | منطق رزرو به چند متد جداگانه تقسیم شد: `applyCityDiscount()`, `handlePayment()`, `printInvoice()`, و `notifyCustomer()`. به این ترتیب هر بخش تنها یک وظیفه مستقل دارد و کلاس نقش هماهنگ‌کننده‌ی سرویس را ایفا می‌کند. |
| **OCP** | `PaymentProcessor` | هنگام افزودن نوع جدید پرداخت، نیاز بود در چند جای کد (از جمله `ReservationService`) تغییر انجام شود. این یعنی کلاس نسبت به تغییرات بسته نبود. | با تمرکز تصمیم‌گیری نوع پرداخت داخل خود کلاس `PaymentProcessor` و استفاده از `PaymentMethods` Enum، وابستگی‌های خارجی حذف شدند. اکنون می‌توان روش‌های جدید پرداخت را تنها با افزودن مقدار جدید در Enum اضافه کرد (کد موجود بدون تغییر باقی می‌ماند). |
| **LSP** | `LuxuryRoom` ← `Room` | رفتار متدهای کلاس فرزند با کلاس والد سازگار نبود؛ تغییر در محاسبه‌ی قیمت باعث می‌شد جایگزینی `LuxuryRoom` به‌جای `Room` خطای منطقی ایجاد کند. | در نسخه اصلاح‌شده، متد `totalPrice()` در `LuxuryRoom` بازنویسی شد تا از منطق والد تبعیت کند و تنها هزینه‌ی اضافی "luxuryFee" را اضافه کند. حالا هر دو کلاس رفتار سازگاری دارند و اصل جانشینی برقرار است. |
| **ISP** | `MessageSender`, `EmailSender`, `SmsSender` | Interface موجود چند متد غیرمرتبط داشت و تمام کلاس‌ها مجبور بودند حتی متدهای نامرتبط را پیاده‌سازی کنند (نقض اصل جداسازی رابط‌ها). | Interface ساده‌تر شد تا فقط متد عمومی `send(String to, String message)` را شامل شود. سپس کلاس‌های `EmailSender` و `SmsSender` هرکدام پیاده‌سازی خاص خود را انجام دادند. حالا هر کلاس فقط متد مورد نیاز خودش را دارد و ISP رعایت شده است. |

## جدول اصلاح موارد نقض  

محمدمهدی حسنی  

| اصل | کلاس تغییر یافته | مشکل در نسخه قبلی | اقدام اصلاحی / رفع نقض |
|------|------------------|--------------------|--------------------------|
| **DIP** | `ReservationService` | این کلاس مستقیماً به کلاس‌های پیاده‌سازی مانند `EmailSender`, `SmsSender`, و `PaymentProcessor` وابسته بود؛ یعنی وابستگی به جزئیات به‌جای انتزاع. این باعث می‌شد اضافه‌کردن روش جدید اعلان یا پرداخت نیازمند تغییر در کد موجود باشد. | وابستگی‌ها از پیاده‌سازی به abstraction منتقل شدند. متد جدید `notifyCustomer()` با استفاده از Interface `MessageSender` ایجاد شد و نمونه‌ی موردنیاز بر اساس نوع اعلان (Email یا SMS) تزریق می‌شود. این‌گونه کلاس تنها با سطوح انتزاع کار می‌کند و اصل **DIP** برقرار است. |
| **PLK** | `Customer`, `Room`, `ReservationService` | کلاس‌ها برای دسترسی به داده‌های داخلی یکدیگر (مثل `customer.city` یا `room.price`) به‌طور مستقیم عمل می‌کردند که وابستگی شدید و اطلاع زیاد از جزئیات سایر کلاس‌ها ایجاد می‌کرد. | متدهای کمکی مانند `isFrom()`, `getContactEmail()` و `getPrice()` در کلاس‌های مدل اضافه شدند تا دسترسی غیرمستقیم برقرار شود. اکنون هیچ کلاسی به ساختار داخلی دیگری وابسته نیست و اصل **PLK** رعایت شده است. |
| **CRP** | `Reservation` | رفتارهایی مانند پردازش پرداخت و ارسال اعلان مستقیماً در این کلاس پیاده‌سازی شده بود و استفاده‌ی مجدد از این منطق در سایر بخش‌ها دشوار بود. | طراحی اصلاح شد تا از **ترکیب (Composition)** به‌جای **ارث‌بری** استفاده شود. فیلدهای `PaymentProcessor` و `MessageSender` به کلاس افزوده شدند و متدهای `setServices()` و `confirm()` برای تزریق وابستگی‌ها در زمان اجرا ایجاد شدند. در نتیجه کلاس از سرویس‌های خارجی استفاده می‌کند و اصل **CRP** برقرار است. |

